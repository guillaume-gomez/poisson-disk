/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/index.js":
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _poissonDiskSampling = _interopRequireDefault(__webpack_require__(/*! poisson-disk-sampling */ \"./node_modules/poisson-disk-sampling/src/poisson-disk-sampling.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar RADIUS = 1;\nvar TREE_X = 5;\nvar TREE_Y = 5;\nvar OFFSET_X_MIN = 0;\nvar OFFSET_X_MAX = 20;\nvar OFFSET_Y_MIN = 0;\nvar OFFSET_Y_MAX = 20;\nvar DEPTH_MAX = 2;\nvar VAR_X = 10;\nvar VAR_Y = 10; // shared variable\n\nvar arrayPoints = [];\nvar minRows = 1;\nvar maxRows = 4;\nvar minColumns = 2;\nvar maxColumns = 3;\nvar minDistanceMin = 2;\nvar minDistanceMax = 5;\nvar maxDistanceMin = 5;\nvar maxDistanceMax = 15;\n\nfunction createCanvas() {\n  var canvas = document.createElement(\"CANVAS\");\n  canvas.width = 100 * 8;\n  canvas.height = 100 * 10;\n  canvas.id = 'myCanvas';\n  canvas.style.backgroundColor = '#9E82B8';\n  var canvasDiv = document.getElementById(\"canvasId\");\n  canvasDiv.appendChild(canvas);\n  return canvas;\n}\n\nfunction bindExportButtonImg(canvas) {\n  $(\"#export-to-png\").click(function () {\n    saveImage(canvas);\n  });\n}\n\nfunction bindExportButtonImgNoBg(canvas) {\n  $(\"#export-to-png-no-bg\").click(function () {\n    saveImage(canvas, false);\n  });\n}\n\nfunction bindResetButton(canvas) {\n  $(\"#reset\").click(function () {\n    var context = canvas.getContext('2d');\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    init(false);\n  });\n}\n\nfunction bindPickColor() {\n  $(\"#dot-color\").change(function () {\n    var newColor = \"#\".concat($(this).val());\n    var canvas = document.getElementById(\"myCanvas\");\n    var context = canvas.getContext('2d');\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    arrayPoints.forEach(function (_ref) {\n      var x = _ref.x,\n          y = _ref.y;\n      createDot(context, x, y, RADIUS, newColor);\n    });\n  });\n}\n\nfunction bindNbRows() {\n  $(\"#nb-rows\").slider({});\n}\n\nfunction bindNbColumns() {\n  $(\"#nb-columns\").slider({});\n}\n\nfunction bindMinDistance() {\n  $(\"#min-distance\").slider({});\n}\n\nfunction bindMaxDistance() {\n  $(\"#max-distance\").slider({});\n}\n\nfunction createText(canvas) {\n  var context = canvas.getContext('2d');\n  context.font = \"20px Arial\";\n  context.fillStyle = \"black\";\n  context.textAlign = \"center\";\n  context.fillText(\"gÂ³\", canvas.width - 15, canvas.height - 15);\n}\n\nfunction init() {\n  var createItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var canvas = document.getElementById(\"myCanvas\");\n  var color = \"#\".concat($(\"#dot-color\").val()) || \"#FF0000\";\n\n  if (createItems) {\n    canvas = createCanvas();\n    bindExportButtonImg(canvas);\n    bindExportButtonImgNoBg(canvas);\n    bindResetButton(canvas);\n    bindPickColor();\n    bindNbRows();\n    bindNbColumns();\n    bindMinDistance();\n    bindMaxDistance();\n  }\n\n  setup(canvas, color);\n}\n\nfunction setup(canvas, color) {\n  arrayPoints = [];\n  var context = canvas.getContext('2d');\n  var rowOptions = $(\"#nb-rows\").slider('getValue');\n  var columnOptions = $(\"#nb-columns\").slider('getValue');\n  var minDistanceOptions = $(\"#min-distance\").slider('getValue');\n  var maxDistanceOptions = $(\"#max-distance\").slider('getValue');\n  minRows = rowOptions[0];\n  maxRows = rowOptions[1];\n  minColumns = columnOptions[0];\n  maxColumns = columnOptions[1];\n  minDistanceMin = minDistanceOptions[0];\n  minDistanceMax = minDistanceOptions[1];\n  maxDistanceMin = maxDistanceOptions[0];\n  maxDistanceMax = maxDistanceOptions[1];\n  generateGroupTree(context, TREE_X, TREE_Y, canvas.width, canvas.height, 1, color);\n}\n\nfunction createDot(context, x, y, radius, color) {\n  context.beginPath();\n  context.arc(x, y, radius, 0, 2 * Math.PI, false);\n  context.fillStyle = color;\n  context.fill();\n}\n\nfunction createGroup(context, radius, xOffset, yOffset, width, height, color) {\n  var minDistance = getRandomInt(minDistanceMin, minDistanceMax);\n  var maxDistance = getRandomInt(maxDistanceMin, maxDistanceMax);\n  var p = new _poissonDiskSampling.default([width, height], minDistance, maxDistance, 30);\n  var points = p.fill();\n  points.forEach(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        x = _ref3[0],\n        y = _ref3[1];\n\n    //save points\n    arrayPoints.push({\n      x: x + xOffset,\n      y: y + yOffset\n    });\n    createDot(context, x + xOffset, y + yOffset, radius, color);\n  });\n}\n\nfunction generateGroupTree(context, x, y, width, height, depth, color) {\n  if (depth > DEPTH_MAX) {\n    createGroup(context, RADIUS, x, y, width, height, color);\n    return;\n  }\n\n  var rows = getRandomInt(minRows, maxRows);\n  var heightGroup = height / rows;\n  var columns = getRandomInt(minColumns, maxColumns);\n  var widthGroup = width / columns;\n  var currentWidth = 0;\n  var currentHeight = 0;\n\n  for (var yOffsetIt = 0; yOffsetIt < rows; yOffsetIt++) {\n    var offsetGroupY = getRandomInt(OFFSET_X_MIN, OFFSET_X_MAX);\n\n    for (var xOffsetIt = 0; xOffsetIt < columns; xOffsetIt++) {\n      var offsetGroupX = getRandomInt(OFFSET_Y_MIN, OFFSET_Y_MAX);\n      currentWidth = xOffsetIt * widthGroup;\n      currentHeight = yOffsetIt * heightGroup;\n      var newWidth = widthGroup;\n      var newHeight = heightGroup;\n      var newX = x + currentWidth;\n      var newY = y + currentHeight;\n      generateGroupTree(context, newX, newY, newWidth - offsetGroupX, newHeight - offsetGroupY, depth + 1, color);\n    }\n  }\n}\n\nfunction saveImage(canvas) {\n  var withBg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  // create a second canvas\n  var destinationCanvas = document.createElement(\"canvas\");\n  destinationCanvas.width = canvas.width;\n  destinationCanvas.height = canvas.height;\n  var destCtx = destinationCanvas.getContext('2d');\n\n  if (withBg) {\n    //create a rectangle with the desired color\n    destCtx.fillStyle = canvas.style.backgroundColor;\n    destCtx.fillRect(0, 0, canvas.width, canvas.height);\n  } //draw the original canvas onto the destination canvas\n\n\n  destCtx.drawImage(canvas, 0, 0); //add signature :)\n  //createText(destinationCanvas);\n\n  var image = destinationCanvas.toDataURL(\"image/png\").replace(\"image/png\", \"image/octet-stream\");\n  window.location.href = image;\n}\n\nfunction getRandomInt(min, max) {\n  return Math.round((max - min) * Math.random()) + min;\n}\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  init();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9pbmRleC5qcz81MzkyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQb2lzc29uIGZyb20gXCJwb2lzc29uLWRpc2stc2FtcGxpbmdcIjtcblxuY29uc3QgUkFESVVTID0gMTtcbmNvbnN0IFRSRUVfWCA9IDU7XG5jb25zdCBUUkVFX1kgPSA1O1xuY29uc3QgT0ZGU0VUX1hfTUlOID0gMDtcbmNvbnN0IE9GRlNFVF9YX01BWCA9IDIwO1xuY29uc3QgT0ZGU0VUX1lfTUlOID0gMDtcbmNvbnN0IE9GRlNFVF9ZX01BWCA9IDIwO1xuY29uc3QgREVQVEhfTUFYID0gMjtcbmNvbnN0IFZBUl9YID0gMTA7XG5jb25zdCBWQVJfWSA9IDEwO1xuXG4vLyBzaGFyZWQgdmFyaWFibGVcbmxldCBhcnJheVBvaW50cyA9IFtdO1xubGV0IG1pblJvd3MgPSAxO1xubGV0IG1heFJvd3MgPSA0O1xubGV0IG1pbkNvbHVtbnMgPSAyO1xubGV0IG1heENvbHVtbnMgPSAzO1xubGV0IG1pbkRpc3RhbmNlTWluID0gMjtcbmxldCBtaW5EaXN0YW5jZU1heCA9IDU7XG5sZXQgbWF4RGlzdGFuY2VNaW4gPSA1O1xubGV0IG1heERpc3RhbmNlTWF4ID0gMTU7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkNBTlZBU1wiKTtcbiAgY2FudmFzLndpZHRoID0gMTAwICogODtcbiAgY2FudmFzLmhlaWdodCA9IDEwMCAqIDEwO1xuICBjYW52YXMuaWQgPSAnbXlDYW52YXMnO1xuICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyM5RTgyQjgnO1xuXG4gIGNvbnN0IGNhbnZhc0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzSWRcIik7XG4gIGNhbnZhc0Rpdi5hcHBlbmRDaGlsZChjYW52YXMpO1xuICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBiaW5kRXhwb3J0QnV0dG9uSW1nKGNhbnZhcykge1xuICAkKFwiI2V4cG9ydC10by1wbmdcIikuY2xpY2soIGZ1bmN0aW9uKCkge1xuICAgIHNhdmVJbWFnZShjYW52YXMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYmluZEV4cG9ydEJ1dHRvbkltZ05vQmcoY2FudmFzKSB7XG4gICQoXCIjZXhwb3J0LXRvLXBuZy1uby1iZ1wiKS5jbGljayggZnVuY3Rpb24oKSB7XG4gICAgc2F2ZUltYWdlKGNhbnZhcywgZmFsc2UpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYmluZFJlc2V0QnV0dG9uKGNhbnZhcykge1xuICAkKFwiI3Jlc2V0XCIpLmNsaWNrKCBmdW5jdGlvbigpIHtcbiAgICBsZXQgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgaW5pdChmYWxzZSlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGJpbmRQaWNrQ29sb3IoKSB7XG4gICQoXCIjZG90LWNvbG9yXCIpLmNoYW5nZSggZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgbmV3Q29sb3IgPSBgIyR7JCh0aGlzKS52YWwoKX1gO1xuICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15Q2FudmFzXCIpO1xuICAgIGxldCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgIGFycmF5UG9pbnRzLmZvckVhY2goKHt4LHl9KSA9PiB7XG4gICAgICBjcmVhdGVEb3QoY29udGV4dCwgeCwgeSwgUkFESVVTLCBuZXdDb2xvcik7XG4gICAgfSk7XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJpbmROYlJvd3MoKSB7XG4gICQoXCIjbmItcm93c1wiKS5zbGlkZXIoe30pO1xufVxuXG5mdW5jdGlvbiBiaW5kTmJDb2x1bW5zKCkge1xuICAkKFwiI25iLWNvbHVtbnNcIikuc2xpZGVyKHt9KTtcbn1cblxuZnVuY3Rpb24gYmluZE1pbkRpc3RhbmNlKCkge1xuICAkKFwiI21pbi1kaXN0YW5jZVwiKS5zbGlkZXIoe30pO1xufVxuXG5mdW5jdGlvbiBiaW5kTWF4RGlzdGFuY2UoKSB7XG4gICQoXCIjbWF4LWRpc3RhbmNlXCIpLnNsaWRlcih7fSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHQoY2FudmFzKSB7XG4gIGxldCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGNvbnRleHQuZm9udCA9IFwiMjBweCBBcmlhbFwiO1xuICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgY29udGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICBjb250ZXh0LmZpbGxUZXh0KFwiZ8KzXCIsIGNhbnZhcy53aWR0aCAtIDE1LCBjYW52YXMuaGVpZ2h0IC0gMTUpO1xufVxuXG5mdW5jdGlvbiBpbml0KGNyZWF0ZUl0ZW1zID0gdHJ1ZSkge1xuICBsZXQgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteUNhbnZhc1wiKTtcbiAgbGV0IGNvbG9yID0gYCMkeyQoXCIjZG90LWNvbG9yXCIpLnZhbCgpfWAgfHwgXCIjRkYwMDAwXCI7XG4gIGlmKGNyZWF0ZUl0ZW1zKSB7XG4gICAgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgYmluZEV4cG9ydEJ1dHRvbkltZyhjYW52YXMpO1xuICAgIGJpbmRFeHBvcnRCdXR0b25JbWdOb0JnKGNhbnZhcyk7XG4gICAgYmluZFJlc2V0QnV0dG9uKGNhbnZhcyk7XG4gICAgYmluZFBpY2tDb2xvcigpO1xuICAgIGJpbmROYlJvd3MoKTtcbiAgICBiaW5kTmJDb2x1bW5zKCk7XG4gICAgYmluZE1pbkRpc3RhbmNlKCk7XG4gICAgYmluZE1heERpc3RhbmNlKCk7XG4gIH1cbiAgc2V0dXAoY2FudmFzLCBjb2xvcik7XG59XG5cbmZ1bmN0aW9uIHNldHVwKGNhbnZhcywgY29sb3IpIHtcbiAgYXJyYXlQb2ludHMgPSBbXTtcbiAgbGV0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY29uc3Qgcm93T3B0aW9ucyA9ICQoXCIjbmItcm93c1wiKS5zbGlkZXIoJ2dldFZhbHVlJyk7XG4gIGNvbnN0IGNvbHVtbk9wdGlvbnMgPSAkKFwiI25iLWNvbHVtbnNcIikuc2xpZGVyKCdnZXRWYWx1ZScpO1xuICBjb25zdCBtaW5EaXN0YW5jZU9wdGlvbnMgPSAkKFwiI21pbi1kaXN0YW5jZVwiKS5zbGlkZXIoJ2dldFZhbHVlJyk7XG4gIGNvbnN0IG1heERpc3RhbmNlT3B0aW9ucyA9ICQoXCIjbWF4LWRpc3RhbmNlXCIpLnNsaWRlcignZ2V0VmFsdWUnKTtcblxuICBtaW5Sb3dzID0gcm93T3B0aW9uc1swXTtcbiAgbWF4Um93cyA9IHJvd09wdGlvbnNbMV07XG4gIG1pbkNvbHVtbnMgPSBjb2x1bW5PcHRpb25zWzBdO1xuICBtYXhDb2x1bW5zID0gY29sdW1uT3B0aW9uc1sxXTtcbiAgbWluRGlzdGFuY2VNaW4gPSBtaW5EaXN0YW5jZU9wdGlvbnNbMF07XG4gIG1pbkRpc3RhbmNlTWF4ID0gbWluRGlzdGFuY2VPcHRpb25zWzFdO1xuICBtYXhEaXN0YW5jZU1pbiA9IG1heERpc3RhbmNlT3B0aW9uc1swXTtcbiAgbWF4RGlzdGFuY2VNYXggPSBtYXhEaXN0YW5jZU9wdGlvbnNbMV07XG5cbiAgZ2VuZXJhdGVHcm91cFRyZWUoY29udGV4dCwgVFJFRV9YLCBUUkVFX1ksIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgMSwgY29sb3IpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEb3QoY29udGV4dCwgeCwgeSwgcmFkaXVzLCBjb2xvcikge1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gIGNvbnRleHQuZmlsbCgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVHcm91cChjb250ZXh0LCByYWRpdXMsIHhPZmZzZXQsIHlPZmZzZXQsIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XG4gIGNvbnN0IG1pbkRpc3RhbmNlID0gZ2V0UmFuZG9tSW50KG1pbkRpc3RhbmNlTWluLCBtaW5EaXN0YW5jZU1heCk7XG4gIGNvbnN0IG1heERpc3RhbmNlID0gZ2V0UmFuZG9tSW50KG1heERpc3RhbmNlTWluLCBtYXhEaXN0YW5jZU1heCk7XG5cbiAgY29uc3QgcCA9IG5ldyBQb2lzc29uKFt3aWR0aCwgaGVpZ2h0XSwgbWluRGlzdGFuY2UsIG1heERpc3RhbmNlLCAzMCk7XG4gIGNvbnN0IHBvaW50cyA9IHAuZmlsbCgpO1xuICBwb2ludHMuZm9yRWFjaCgoW3gseV0pID0+IHtcbiAgICAvL3NhdmUgcG9pbnRzXG4gICAgYXJyYXlQb2ludHMucHVzaCh7eDogeCArIHhPZmZzZXQsIHk6IHkgKyB5T2Zmc2V0fSk7XG5cbiAgICBjcmVhdGVEb3QoY29udGV4dCwgeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCByYWRpdXMsIGNvbG9yKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlR3JvdXBUcmVlKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBjb2xvcikge1xuICBpZihkZXB0aCA+IERFUFRIX01BWCkge1xuICAgIGNyZWF0ZUdyb3VwKGNvbnRleHQsIFJBRElVUywgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByb3dzID0gZ2V0UmFuZG9tSW50KG1pblJvd3MsIG1heFJvd3MpO1xuICBjb25zdCBoZWlnaHRHcm91cCA9IGhlaWdodCAvIHJvd3M7XG5cbiAgY29uc3QgY29sdW1ucyA9IGdldFJhbmRvbUludChtaW5Db2x1bW5zLCBtYXhDb2x1bW5zKTtcbiAgY29uc3Qgd2lkdGhHcm91cCA9IHdpZHRoIC8gY29sdW1ucztcblxuICBsZXQgY3VycmVudFdpZHRoID0gMDtcbiAgbGV0IGN1cnJlbnRIZWlnaHQgPSAwO1xuICBmb3IobGV0IHlPZmZzZXRJdCA9IDA7IHlPZmZzZXRJdCA8IHJvd3M7IHlPZmZzZXRJdCsrKSB7XG4gICAgY29uc3Qgb2Zmc2V0R3JvdXBZID0gZ2V0UmFuZG9tSW50KE9GRlNFVF9YX01JTiwgT0ZGU0VUX1hfTUFYKTtcbiAgICBmb3IobGV0IHhPZmZzZXRJdCA9IDA7IHhPZmZzZXRJdCA8IGNvbHVtbnM7IHhPZmZzZXRJdCsrKSB7XG4gICAgICBjb25zdCBvZmZzZXRHcm91cFggPSBnZXRSYW5kb21JbnQoT0ZGU0VUX1lfTUlOLCBPRkZTRVRfWV9NQVgpO1xuXG4gICAgICBjdXJyZW50V2lkdGggPSAoeE9mZnNldEl0ICogd2lkdGhHcm91cCk7XG4gICAgICBjdXJyZW50SGVpZ2h0ID0gKHlPZmZzZXRJdCAqIGhlaWdodEdyb3VwKTtcbiAgICAgIGNvbnN0IG5ld1dpZHRoID0gd2lkdGhHcm91cDtcbiAgICAgIGNvbnN0IG5ld0hlaWdodCA9IGhlaWdodEdyb3VwO1xuICAgICAgY29uc3QgbmV3WCA9IHggKyBjdXJyZW50V2lkdGg7XG4gICAgICBjb25zdCBuZXdZID0geSArIGN1cnJlbnRIZWlnaHQ7XG4gICAgICBnZW5lcmF0ZUdyb3VwVHJlZShjb250ZXh0LCBuZXdYLCBuZXdZLCBuZXdXaWR0aCAtIG9mZnNldEdyb3VwWCwgbmV3SGVpZ2h0IC0gb2Zmc2V0R3JvdXBZLCBkZXB0aCArIDEsIGNvbG9yKTtcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzYXZlSW1hZ2UoY2FudmFzLCB3aXRoQmcgPSB0cnVlKSB7XG4gIC8vIGNyZWF0ZSBhIHNlY29uZCBjYW52YXNcbiAgbGV0IGRlc3RpbmF0aW9uQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgZGVzdGluYXRpb25DYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gIGRlc3RpbmF0aW9uQ2FudmFzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG5cbiAgbGV0IGRlc3RDdHggPSBkZXN0aW5hdGlvbkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBpZiAod2l0aEJnKSB7XG4gICAgLy9jcmVhdGUgYSByZWN0YW5nbGUgd2l0aCB0aGUgZGVzaXJlZCBjb2xvclxuICAgIGRlc3RDdHguZmlsbFN0eWxlID0gY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICBkZXN0Q3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIH1cblxuICAvL2RyYXcgdGhlIG9yaWdpbmFsIGNhbnZhcyBvbnRvIHRoZSBkZXN0aW5hdGlvbiBjYW52YXNcbiAgZGVzdEN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblxuICAvL2FkZCBzaWduYXR1cmUgOilcbiAgLy9jcmVhdGVUZXh0KGRlc3RpbmF0aW9uQ2FudmFzKTtcbiAgY29uc3QgaW1hZ2UgPSBkZXN0aW5hdGlvbkNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIikucmVwbGFjZShcImltYWdlL3BuZ1wiLCBcImltYWdlL29jdGV0LXN0cmVhbVwiKTtcbiAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBpbWFnZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gIHJldHVybiAoTWF0aC5yb3VuZCgobWF4IC0gbWluKSAqIE1hdGgucmFuZG9tKCkpICsgbWluKTtcbn1cblxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICBpbml0KCk7XG59KTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOzs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/index.js\n");

/***/ }),

/***/ "./node_modules/iota-array/iota.js":
/*!*****************************************!*\
  !*** ./node_modules/iota-array/iota.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW90YS1hcnJheS9pb3RhLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qcz8yMDMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGlvdGEobikge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IGlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW90YSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/iota-array/iota.js\n");

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcz8wNDRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/is-buffer/index.js\n");

/***/ }),

/***/ "./node_modules/moore/index.js":
/*!*************************************!*\
  !*** ./node_modules/moore/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function moore(range, dimensions) {\n  range = range || 1\n  dimensions = dimensions || 2\n\n  var size = range * 2 + 1\n  var length = Math.pow(size, dimensions) - 1\n  var neighbors = new Array(length)\n\n  for (var i = 0; i < length; i++) {\n    var neighbor = neighbors[i] = new Array(dimensions)\n    var index = i < length / 2 ? i : i + 1\n    for (var dimension = 1; dimension <= dimensions; dimension++) {\n      var value = index % Math.pow(size, dimension)\n      neighbor[dimension - 1] = value / Math.pow(size, dimension - 1) - range\n      index -= value\n    }\n  }\n\n  return neighbors\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9vcmUvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9vcmUvaW5kZXguanM/OTMzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1vb3JlKHJhbmdlLCBkaW1lbnNpb25zKSB7XG4gIHJhbmdlID0gcmFuZ2UgfHwgMVxuICBkaW1lbnNpb25zID0gZGltZW5zaW9ucyB8fCAyXG5cbiAgdmFyIHNpemUgPSByYW5nZSAqIDIgKyAxXG4gIHZhciBsZW5ndGggPSBNYXRoLnBvdyhzaXplLCBkaW1lbnNpb25zKSAtIDFcbiAgdmFyIG5laWdoYm9ycyA9IG5ldyBBcnJheShsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tpXSA9IG5ldyBBcnJheShkaW1lbnNpb25zKVxuICAgIHZhciBpbmRleCA9IGkgPCBsZW5ndGggLyAyID8gaSA6IGkgKyAxXG4gICAgZm9yICh2YXIgZGltZW5zaW9uID0gMTsgZGltZW5zaW9uIDw9IGRpbWVuc2lvbnM7IGRpbWVuc2lvbisrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbmRleCAlIE1hdGgucG93KHNpemUsIGRpbWVuc2lvbilcbiAgICAgIG5laWdoYm9yW2RpbWVuc2lvbiAtIDFdID0gdmFsdWUgLyBNYXRoLnBvdyhzaXplLCBkaW1lbnNpb24gLSAxKSAtIHJhbmdlXG4gICAgICBpbmRleCAtPSB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWlnaGJvcnNcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/moore/index.js\n");

/***/ }),

/***/ "./node_modules/ndarray/ndarray.js":
/*!*****************************************!*\
  !*** ./node_modules/ndarray/ndarray.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iota = __webpack_require__(/*! iota-array */ \"./node_modules/iota-array/iota.js\")\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcz9iNWJiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpb3RhID0gcmVxdWlyZShcImlvdGEtYXJyYXlcIilcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoXCJpcy1idWZmZXJcIilcblxudmFyIGhhc1R5cGVkQXJyYXlzICA9ICgodHlwZW9mIEZsb2F0NjRBcnJheSkgIT09IFwidW5kZWZpbmVkXCIpXG5cbmZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gb3JkZXIoKSB7XG4gIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZVxuICB2YXIgdGVybXMgPSBuZXcgQXJyYXkoc3RyaWRlLmxlbmd0aClcbiAgdmFyIGlcbiAgZm9yKGk9MDsgaTx0ZXJtcy5sZW5ndGg7ICsraSkge1xuICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldXG4gIH1cbiAgdGVybXMuc29ydChjb21wYXJlMXN0KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRlcm1zLmxlbmd0aClcbiAgZm9yKGk9MDsgaTxyZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0ZXJtc1tpXVsxXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBkaW1lbnNpb24pIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIilcbiAgaWYoZGltZW5zaW9uIDwgMCkge1xuICAgIGNsYXNzTmFtZSA9IFwiVmlld19OaWxcIiArIGR0eXBlXG4gIH1cbiAgdmFyIHVzZUdldHRlcnMgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuXG4gIGlmKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgdHJpdmlhbCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhKXt0aGlzLmRhdGE9YTt9O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O1xcXG5wcm90by5zaXplPTA7XFxcbnByb3RvLmRpbWVuc2lvbj0tMTtcXFxucHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1wcm90by5oaT1wcm90by50cmFuc3Bvc2U9cHJvdG8uc3RlcD1cXFxuZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEpO307XFxcbnByb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhKTt9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZSgpXG4gIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDApIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgMGQgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxkKSB7XFxcbnRoaXMuZGF0YSA9IGE7XFxcbnRoaXMub2Zmc2V0ID0gZFxcXG59O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vZmZzZXR9O1xcXG5wcm90by5kaW1lbnNpb249MDtcXFxucHJvdG8uc2l6ZT0xO1xcXG5wcm90by5zaGFwZT1cXFxucHJvdG8uc3RyaWRlPVxcXG5wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89XFxcbnByb3RvLmhpPVxcXG5wcm90by50cmFuc3Bvc2U9XFxcbnByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2NvcHkoKSB7XFxcbnJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSx0aGlzLm9mZnNldClcXFxufTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljaygpe1xcXG5yZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7XFxcbn07XFxcbnByb3RvLnZhbHVlT2Y9cHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoKXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1xuXCJ9O1xcXG5wcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldCh2KXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuc2V0KHRoaXMub2Zmc2V0LHYpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF09dlwiKStcIlxcXG59O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhLGIsYyxkKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhLGQpfVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIlRyaXZpYWxBcnJheVwiLCBjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1bMF0pXG4gIH1cblxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuXG4gIC8vQ3JlYXRlIGNvbnN0cnVjdG9yIGZvciB2aWV3XG4gIHZhciBpbmRpY2VzID0gaW90YShkaW1lbnNpb24pXG4gIHZhciBhcmdzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJpXCIraSB9KVxuICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGlcbiAgICAgIH0pLmpvaW4oXCIrXCIpXG4gIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgdmFyIHN0cmlkZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgY29kZS5wdXNoKFxuICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgIFwidGhpcy5zaGFwZT1bXCIgKyBzaGFwZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLnN0cmlkZT1bXCIgKyBzdHJpZGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgIFwidmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGVcIixcbiAgICBcInByb3RvLmR0eXBlPSdcIitkdHlwZStcIidcIixcbiAgICBcInByb3RvLmRpbWVuc2lvbj1cIitkaW1lbnNpb24pXG5cbiAgLy92aWV3LnNpemU6XG4gIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2l6ZSgpe1xcXG5yZXR1cm4gXCIraW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJ0aGlzLnNoYXBlW1wiK2krXCJdXCIgfSkuam9pbihcIipcIiksXG5cIn19KVwiKVxuXG4gIC8vdmlldy5vcmRlcjpcbiAgaWYoZGltZW5zaW9uID09PSAxKSB7XG4gICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIilcbiAgICBpZihkaW1lbnNpb24gPCA0KSB7XG4gICAgICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfb3JkZXIoKXtcIilcbiAgICAgIGlmKGRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpXG4gICAgICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgIGNvZGUucHVzaChcblwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO1xcXG5pZihzMD5zMSl7XFxcbmlmKHMxPnMyKXtcXFxucmV0dXJuIFsyLDEsMF07XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsxLDIsMF07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzEsMCwyXTtcXFxufVxcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMiwwLDFdO1xcXG59ZWxzZSBpZihzMj5zMSl7XFxcbnJldHVybiBbMCwxLDJdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFswLDIsMV07XFxcbn19fSlcIilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKVxuICAgIH1cbiAgfVxuXG4gIC8vdmlldy5zZXQoaTAsIC4uLiwgdik6XG4gIGNvZGUucHVzaChcblwicHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIix2KXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2luZGV4X3N0citcIix2KX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl09dn1cIilcbiAgfVxuXG4gIC8vdmlldy5nZXQoaTAsIC4uLik6XG4gIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIraW5kZXhfc3RyK1wiKX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl19XCIpXG4gIH1cblxuICAvL3ZpZXcuaW5kZXg6XG4gIGNvZGUucHVzaChcbiAgICBcInByb3RvLmluZGV4PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9pbmRleChcIiwgYXJncy5qb2luKCksIFwiKXtyZXR1cm4gXCIraW5kZXhfc3RyK1wifVwiKVxuXG4gIC8vdmlldy5oaSgpOlxuICBjb2RlLnB1c2goXCJwcm90by5oaT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaGkoXCIrYXJncy5qb2luKFwiLFwiKStcIil7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBbXCIodHlwZW9mIGlcIixpLFwiIT09J251bWJlcid8fGlcIixpLFwiPDApP3RoaXMuc2hhcGVbXCIsIGksIFwiXTppXCIsIGksXCJ8MFwiXS5qb2luKFwiXCIpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIraSArIFwiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5sbygpOlxuICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCIgfSlcbiAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiY1wiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIiB9KVxuICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfbG8oXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIGI9dGhpcy5vZmZzZXQsZD0wLFwiK2FfdmFycy5qb2luKFwiLFwiKStcIixcIitjX3ZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe1xcXG5kPWlcIitpK1wifDA7XFxcbmIrPWNcIitpK1wiKmQ7XFxcbmFcIitpK1wiLT1kfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYil9XCIpXG5cbiAgLy92aWV3LnN0ZXAoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc3RlcChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGM9dGhpcy5vZmZzZXQsZD0wLGNlaWw9TWF0aC5jZWlsXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuaWYoZDwwKXtcXFxuYys9YlwiK2krXCIqKGFcIitpK1wiLTEpO1xcXG5hXCIraStcIj1jZWlsKC1hXCIraStcIi9kKVxcXG59ZWxzZXtcXFxuYVwiK2krXCI9Y2VpbChhXCIraStcIi9kKVxcXG59XFxcbmJcIitpK1wiKj1kXFxcbn1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixjKX1cIilcblxuICAvL3ZpZXcudHJhbnNwb3NlKCk6XG4gIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICB2YXIgdFN0cmlkZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdFNoYXBlW2ldID0gXCJhW2lcIitpK1wiXVwiXG4gICAgdFN0cmlkZVtpXSA9IFwiYltpXCIraStcIl1cIlxuICB9XG4gIGNvZGUucHVzaChcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfdHJhbnNwb3NlKFwiK2FyZ3MrXCIpe1wiK1xuICAgIGFyZ3MubWFwKGZ1bmN0aW9uKG4saWR4KSB7IHJldHVybiBuICsgXCI9KFwiICsgbiArIFwiPT09dW5kZWZpbmVkP1wiICsgaWR4ICsgXCI6XCIgKyBuICsgXCJ8MClcIn0pLmpvaW4oXCI7XCIpLFxuICAgIFwidmFyIGE9dGhpcy5zaGFwZSxiPXRoaXMuc3RyaWRlO3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIit0U2hhcGUuam9pbihcIixcIikrXCIsXCIrdFN0cmlkZS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG5cbiAgLy92aWV3LnBpY2soKTpcbiAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljayhcIithcmdzK1wiKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy5vZmZzZXRcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIraStcIl0qaVwiK2krXCIpfDB9ZWxzZXthLnB1c2godGhpcy5zaGFwZVtcIitpK1wiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiK2krXCJdKX1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIilcblxuICAvL0FkZCByZXR1cm4gc3RhdGVtZW50XG4gIGNvZGUucHVzaChcInJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixvZmZzZXQpfVwiKVxuXG4gIC8vQ29tcGlsZSBwcm9jZWR1cmVcbiAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIkNUT1JfTElTVFwiLCBcIk9SREVSXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXSwgb3JkZXIpXG59XG5cbmZ1bmN0aW9uIGFycmF5RFR5cGUoZGF0YSkge1xuICBpZihpc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBcImJ1ZmZlclwiXG4gIH1cbiAgaWYoaGFzVHlwZWRBcnJheXMpIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4X2NsYW1wZWRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJidWZmZXJcIjpbXSxcbiAgXCJnZW5lcmljXCI6W11cbn1cblxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBDQUNIRURfQ09OU1RSVUNUT1JTKSB7XG4gICAgQ0FDSEVEX0NPTlNUUlVDVE9SU1tpZF0ucHVzaChjb21waWxlQ29uc3RydWN0b3IoaWQsIC0xKSlcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdyYXBwZWROREFycmF5Q3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN0b3IgPSBDQUNIRURfQ09OU1RSVUNUT1JTLmFycmF5WzBdXG4gICAgcmV0dXJuIGN0b3IoW10pXG4gIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGRhdGEgPSBbZGF0YV1cbiAgfVxuICBpZihzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2hhcGUgPSBbIGRhdGEubGVuZ3RoIF1cbiAgfVxuICB2YXIgZCA9IHNoYXBlLmxlbmd0aFxuICBpZihzdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlkZSA9IG5ldyBBcnJheShkKVxuICAgIGZvcih2YXIgaT1kLTEsIHN6PTE7IGk+PTA7IC0taSkge1xuICAgICAgc3RyaWRlW2ldID0gc3pcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9XG4gIGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgaWYoc3RyaWRlW2ldIDwgMCkge1xuICAgICAgICBvZmZzZXQgLT0gKHNoYXBlW2ldLTEpKnN0cmlkZVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZHR5cGUgPSBhcnJheURUeXBlKGRhdGEpXG4gIHZhciBjdG9yX2xpc3QgPSBDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVxuICB3aGlsZShjdG9yX2xpc3QubGVuZ3RoIDw9IGQrMSkge1xuICAgIGN0b3JfbGlzdC5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgY3Rvcl9saXN0Lmxlbmd0aC0xKSlcbiAgfVxuICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkKzFdXG4gIHJldHVybiBjdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVkTkRBcnJheUN0b3JcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ndarray/ndarray.js\n");

/***/ }),

/***/ "./node_modules/poisson-disk-sampling/src/poisson-disk-sampling.js":
/*!*************************************************************************!*\
  !*** ./node_modules/poisson-disk-sampling/src/poisson-disk-sampling.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar zeros = __webpack_require__(/*! zeros */ \"./node_modules/zeros/zeros.js\"),\n    moore = __webpack_require__(/*! moore */ \"./node_modules/moore/index.js\"),\n    sphereRandom = __webpack_require__(/*! ./sphere-random */ \"./node_modules/poisson-disk-sampling/src/sphere-random.js\");\n\n/**\n * Get the squared euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Squared euclidean distance\n */\nvar squaredEuclideanDistance = function squaredEuclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return result;\n};\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nvar getNeighbourhood = function getNeighbourhood (dimensionNumber) {\n    var neighbourhood = moore(2, dimensionNumber),\n        origin = [],\n        dimension;\n\n    for (dimension = 0; dimension < dimensionNumber; dimension++) {\n        origin.push(0);\n    }\n\n    neighbourhood.push(origin);\n\n    // sort by ascending distance to optimize proximity checks\n    // see point 5.1 in Parallel Poisson Disk Sampling by Li-Yi Wei, 2008\n    // http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.460.3061&rank=1\n    neighbourhood.sort(function (n1, n2) {\n        var squareDist1 = 0,\n            squareDist2 = 0;\n\n        for (var dimension = 0; dimension < dimensionNumber; dimension++) {\n            squareDist1 += Math.pow(n1[dimension], 2);\n            squareDist2 += Math.pow(n2[dimension], 2);\n        }\n\n        if (squareDist1 < squareDist2) {\n            return -1;\n        } else if(squareDist1 > squareDist2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    });\n\n    return neighbourhood;\n};\n\n\n/**\n * PoissonDiskSampling constructor\n * @param {Array} shape Shape of the space\n * @param {float} minDistance Minimum distance between each points\n * @param {float} [maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [maxTries] Number of times the algorithm has to try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nvar PoissonDiskSampling = function PoissonDiskSampling (shape, minDistance, maxDistance, maxTries, rng) {\n    maxDistance = maxDistance || minDistance * 2;\n\n    this.shape = shape;\n    this.dimension = this.shape.length;\n    this.minDistance = minDistance;\n    this.squaredMinDistance = minDistance * minDistance;\n    this.deltaDistance = maxDistance - minDistance;\n    this.cellSize = minDistance / Math.sqrt(this.dimension);\n    this.maxTries = maxTries || 30;\n    this.rng = rng || Math.random;\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.processList = [];\n    this.samplePoints = [];\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(shape[i] / this.cellSize));\n    }\n\n    this.grid = zeros(this.gridShape, 'uint32'); //will store references to samplePoints\n};\n\nPoissonDiskSampling.prototype.shape = null;\nPoissonDiskSampling.prototype.dimension = null;\nPoissonDiskSampling.prototype.minDistance = null;\nPoissonDiskSampling.prototype.squaredMinDistance = null;\nPoissonDiskSampling.prototype.deltaDistance = null;\nPoissonDiskSampling.prototype.cellSize = null;\nPoissonDiskSampling.prototype.maxTries = null;\nPoissonDiskSampling.prototype.rng = null;\nPoissonDiskSampling.prototype.neighbourhood = null;\n\nPoissonDiskSampling.prototype.currentPoint = null;\nPoissonDiskSampling.prototype.processList = null;\nPoissonDiskSampling.prototype.samplePoints = null;\nPoissonDiskSampling.prototype.gridShape = null;\nPoissonDiskSampling.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nPoissonDiskSampling.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nPoissonDiskSampling.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] <= this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nPoissonDiskSampling.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        dimension;\n\n    this.processList.push(point);\n    this.samplePoints.push(point);\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex] = this.samplePoints.length; // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nPoissonDiskSampling.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint;\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue >= 0 && currentDimensionValue < this.gridShape[dimension]) {\n                internalArrayIndex += currentDimensionValue * stride[dimension];\n            }\n        }\n\n        if (this.grid.data[internalArrayIndex] !== 0) {\n            existingPoint = this.samplePoints[this.grid.data[internalArrayIndex] - 1];\n\n            if (squaredEuclideanDistance(point, existingPoint) < this.squaredMinDistance) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nPoissonDiskSampling.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            this.currentPoint = this.processList.shift();\n        }\n\n        currentPoint = this.currentPoint;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistance + this.deltaDistance * this.rng();\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] <= this.shape[i] - 1)\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nPoissonDiskSampling.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = 0;\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = PoissonDiskSampling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9pc3Nvbi1kaXNrLXNhbXBsaW5nL3NyYy9wb2lzc29uLWRpc2stc2FtcGxpbmcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9pc3Nvbi1kaXNrLXNhbXBsaW5nL3NyYy9wb2lzc29uLWRpc2stc2FtcGxpbmcuanM/ZmY4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHplcm9zID0gcmVxdWlyZSgnemVyb3MnKSxcbiAgICBtb29yZSA9IHJlcXVpcmUoJ21vb3JlJyksXG4gICAgc3BoZXJlUmFuZG9tID0gcmVxdWlyZSgnLi9zcGhlcmUtcmFuZG9tJyk7XG5cbi8qKlxuICogR2V0IHRoZSBzcXVhcmVkIGV1Y2xpZGVhbiBkaXN0YW5jZSBmcm9tIHR3byBwb2ludHMgb2YgYXJiaXRyYXJ5LCBidXQgZXF1YWwsIGRpbWVuc2lvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50MVxuICogQHBhcmFtIHtBcnJheX0gcG9pbnQyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTcXVhcmVkIGV1Y2xpZGVhbiBkaXN0YW5jZVxuICovXG52YXIgc3F1YXJlZEV1Y2xpZGVhbkRpc3RhbmNlID0gZnVuY3Rpb24gc3F1YXJlZEV1Y2xpZGVhbkRpc3RhbmNlIChwb2ludDEsIHBvaW50Mikge1xuICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgcG9pbnQxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBNYXRoLnBvdyhwb2ludDFbaV0gLSBwb2ludDJbaV0sIDIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbmVpZ2hib3VyaG9vZCBvcmRlcmVkIGJ5IGRpc3RhbmNlLCBpbmNsdWRpbmcgdGhlIG9yaWdpbiBwb2ludFxuICogQHBhcmFtIHtpbnR9IGRpbWVuc2lvbk51bWJlciBOdW1iZXIgb2YgZGltZW5zaW9uc1xuICogQHJldHVybnMge0FycmF5fSBOZWlnaGJvdXJob29kXG4gKi9cbnZhciBnZXROZWlnaGJvdXJob29kID0gZnVuY3Rpb24gZ2V0TmVpZ2hib3VyaG9vZCAoZGltZW5zaW9uTnVtYmVyKSB7XG4gICAgdmFyIG5laWdoYm91cmhvb2QgPSBtb29yZSgyLCBkaW1lbnNpb25OdW1iZXIpLFxuICAgICAgICBvcmlnaW4gPSBbXSxcbiAgICAgICAgZGltZW5zaW9uO1xuXG4gICAgZm9yIChkaW1lbnNpb24gPSAwOyBkaW1lbnNpb24gPCBkaW1lbnNpb25OdW1iZXI7IGRpbWVuc2lvbisrKSB7XG4gICAgICAgIG9yaWdpbi5wdXNoKDApO1xuICAgIH1cblxuICAgIG5laWdoYm91cmhvb2QucHVzaChvcmlnaW4pO1xuXG4gICAgLy8gc29ydCBieSBhc2NlbmRpbmcgZGlzdGFuY2UgdG8gb3B0aW1pemUgcHJveGltaXR5IGNoZWNrc1xuICAgIC8vIHNlZSBwb2ludCA1LjEgaW4gUGFyYWxsZWwgUG9pc3NvbiBEaXNrIFNhbXBsaW5nIGJ5IExpLVlpIFdlaSwgMjAwOFxuICAgIC8vIGh0dHA6Ly9jaXRlc2VlcnguaXN0LnBzdS5lZHUvdmlld2RvYy9zdW1tYXJ5P2RvaT0xMC4xLjEuNDYwLjMwNjEmcmFuaz0xXG4gICAgbmVpZ2hib3VyaG9vZC5zb3J0KGZ1bmN0aW9uIChuMSwgbjIpIHtcbiAgICAgICAgdmFyIHNxdWFyZURpc3QxID0gMCxcbiAgICAgICAgICAgIHNxdWFyZURpc3QyID0gMDtcblxuICAgICAgICBmb3IgKHZhciBkaW1lbnNpb24gPSAwOyBkaW1lbnNpb24gPCBkaW1lbnNpb25OdW1iZXI7IGRpbWVuc2lvbisrKSB7XG4gICAgICAgICAgICBzcXVhcmVEaXN0MSArPSBNYXRoLnBvdyhuMVtkaW1lbnNpb25dLCAyKTtcbiAgICAgICAgICAgIHNxdWFyZURpc3QyICs9IE1hdGgucG93KG4yW2RpbWVuc2lvbl0sIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNxdWFyZURpc3QxIDwgc3F1YXJlRGlzdDIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmKHNxdWFyZURpc3QxID4gc3F1YXJlRGlzdDIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuZWlnaGJvdXJob29kO1xufTtcblxuXG4vKipcbiAqIFBvaXNzb25EaXNrU2FtcGxpbmcgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IHNoYXBlIFNoYXBlIG9mIHRoZSBzcGFjZVxuICogQHBhcmFtIHtmbG9hdH0gbWluRGlzdGFuY2UgTWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIGVhY2ggcG9pbnRzXG4gKiBAcGFyYW0ge2Zsb2F0fSBbbWF4RGlzdGFuY2VdIE1heGltdW0gZGlzdGFuY2UgYmV0d2VlbiBlYWNoIHBvaW50cywgZGVmYXVsdHMgdG8gbWluRGlzdGFuY2UgKiAyXG4gKiBAcGFyYW0ge2ludH0gW21heFRyaWVzXSBOdW1iZXIgb2YgdGltZXMgdGhlIGFsZ29yaXRobSBoYXMgdG8gdHJ5IHRvIHBsYWNlIGEgcG9pbnQgaW4gdGhlIG5laWdoYm91cmhvb2Qgb2YgYW5vdGhlciBwb2ludHMsIGRlZmF1bHRzIHRvIDMwXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IFtybmddIFJORyBmdW5jdGlvbiwgZGVmYXVsdHMgdG8gTWF0aC5yYW5kb21cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUG9pc3NvbkRpc2tTYW1wbGluZyA9IGZ1bmN0aW9uIFBvaXNzb25EaXNrU2FtcGxpbmcgKHNoYXBlLCBtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UsIG1heFRyaWVzLCBybmcpIHtcbiAgICBtYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlIHx8IG1pbkRpc3RhbmNlICogMjtcblxuICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICB0aGlzLmRpbWVuc2lvbiA9IHRoaXMuc2hhcGUubGVuZ3RoO1xuICAgIHRoaXMubWluRGlzdGFuY2UgPSBtaW5EaXN0YW5jZTtcbiAgICB0aGlzLnNxdWFyZWRNaW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2U7XG4gICAgdGhpcy5kZWx0YURpc3RhbmNlID0gbWF4RGlzdGFuY2UgLSBtaW5EaXN0YW5jZTtcbiAgICB0aGlzLmNlbGxTaXplID0gbWluRGlzdGFuY2UgLyBNYXRoLnNxcnQodGhpcy5kaW1lbnNpb24pO1xuICAgIHRoaXMubWF4VHJpZXMgPSBtYXhUcmllcyB8fCAzMDtcbiAgICB0aGlzLnJuZyA9IHJuZyB8fCBNYXRoLnJhbmRvbTtcblxuICAgIHRoaXMubmVpZ2hib3VyaG9vZCA9IGdldE5laWdoYm91cmhvb2QodGhpcy5kaW1lbnNpb24pO1xuXG4gICAgdGhpcy5jdXJyZW50UG9pbnQgPSBudWxsO1xuICAgIHRoaXMucHJvY2Vzc0xpc3QgPSBbXTtcbiAgICB0aGlzLnNhbXBsZVBvaW50cyA9IFtdO1xuXG4gICAgLy8gY2FjaGUgZ3JpZFxuXG4gICAgdGhpcy5ncmlkU2hhcGUgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1lbnNpb247IGkrKykge1xuICAgICAgICB0aGlzLmdyaWRTaGFwZS5wdXNoKE1hdGguY2VpbChzaGFwZVtpXSAvIHRoaXMuY2VsbFNpemUpKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyaWQgPSB6ZXJvcyh0aGlzLmdyaWRTaGFwZSwgJ3VpbnQzMicpOyAvL3dpbGwgc3RvcmUgcmVmZXJlbmNlcyB0byBzYW1wbGVQb2ludHNcbn07XG5cblBvaXNzb25EaXNrU2FtcGxpbmcucHJvdG90eXBlLnNoYXBlID0gbnVsbDtcblBvaXNzb25EaXNrU2FtcGxpbmcucHJvdG90eXBlLmRpbWVuc2lvbiA9IG51bGw7XG5Qb2lzc29uRGlza1NhbXBsaW5nLnByb3RvdHlwZS5taW5EaXN0YW5jZSA9IG51bGw7XG5Qb2lzc29uRGlza1NhbXBsaW5nLnByb3RvdHlwZS5zcXVhcmVkTWluRGlzdGFuY2UgPSBudWxsO1xuUG9pc3NvbkRpc2tTYW1wbGluZy5wcm90b3R5cGUuZGVsdGFEaXN0YW5jZSA9IG51bGw7XG5Qb2lzc29uRGlza1NhbXBsaW5nLnByb3RvdHlwZS5jZWxsU2l6ZSA9IG51bGw7XG5Qb2lzc29uRGlza1NhbXBsaW5nLnByb3RvdHlwZS5tYXhUcmllcyA9IG51bGw7XG5Qb2lzc29uRGlza1NhbXBsaW5nLnByb3RvdHlwZS5ybmcgPSBudWxsO1xuUG9pc3NvbkRpc2tTYW1wbGluZy5wcm90b3R5cGUubmVpZ2hib3VyaG9vZCA9IG51bGw7XG5cblBvaXNzb25EaXNrU2FtcGxpbmcucHJvdG90eXBlLmN1cnJlbnRQb2ludCA9IG51bGw7XG5Qb2lzc29uRGlza1NhbXBsaW5nLnByb3RvdHlwZS5wcm9jZXNzTGlzdCA9IG51bGw7XG5Qb2lzc29uRGlza1NhbXBsaW5nLnByb3RvdHlwZS5zYW1wbGVQb2ludHMgPSBudWxsO1xuUG9pc3NvbkRpc2tTYW1wbGluZy5wcm90b3R5cGUuZ3JpZFNoYXBlID0gbnVsbDtcblBvaXNzb25EaXNrU2FtcGxpbmcucHJvdG90eXBlLmdyaWQgPSBudWxsO1xuXG4vKipcbiAqIEFkZCBhIHRvdGFsbHkgcmFuZG9tIHBvaW50IGluIHRoZSBncmlkXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBwb2ludCBhZGRlZCB0byB0aGUgZ3JpZFxuICovXG5Qb2lzc29uRGlza1NhbXBsaW5nLnByb3RvdHlwZS5hZGRSYW5kb21Qb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9pbnQgPSBuZXcgQXJyYXkodGhpcy5kaW1lbnNpb24pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICAgIHBvaW50W2ldID0gdGhpcy5ybmcoKSAqIHRoaXMuc2hhcGVbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGlyZWN0QWRkUG9pbnQocG9pbnQpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBnaXZlbiBwb2ludCB0byB0aGUgZ3JpZFxuICogQHBhcmFtIHtBcnJheX0gcG9pbnQgUG9pbnRcbiAqIEByZXR1cm5zIHtBcnJheXxudWxsfSBUaGUgcG9pbnQgYWRkZWQgdG8gdGhlIGdyaWQsIG51bGwgaWYgdGhlIHBvaW50IGlzIG91dCBvZiB0aGUgYm91bmQgb3Igbm90IG9mIHRoZSBjb3JyZWN0IGRpbWVuc2lvblxuICovXG5Qb2lzc29uRGlza1NhbXBsaW5nLnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBkaW1lbnNpb24sXG4gICAgICAgIHZhbGlkID0gdHJ1ZTtcblxuICAgIGlmIChwb2ludC5sZW5ndGggPT09IHRoaXMuZGltZW5zaW9uKSB7XG4gICAgICAgIGZvciAoZGltZW5zaW9uID0gMDsgZGltZW5zaW9uIDwgdGhpcy5kaW1lbnNpb24gJiYgdmFsaWQ7IGRpbWVuc2lvbisrKSB7XG4gICAgICAgICAgICB2YWxpZCA9IChwb2ludFtkaW1lbnNpb25dID49IDAgJiYgcG9pbnRbZGltZW5zaW9uXSA8PSB0aGlzLnNoYXBlW2RpbWVuc2lvbl0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWQgPyB0aGlzLmRpcmVjdEFkZFBvaW50KHBvaW50KSA6IG51bGw7XG59O1xuXG4vKipcbiAqIEFkZCBhIGdpdmVuIHBvaW50IHRvIHRoZSBncmlkLCB3aXRob3V0IGFueSBjaGVja1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnQgUG9pbnRcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHBvaW50IGFkZGVkIHRvIHRoZSBncmlkXG4gKiBAcHJvdGVjdGVkXG4gKi9cblBvaXNzb25EaXNrU2FtcGxpbmcucHJvdG90eXBlLmRpcmVjdEFkZFBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIGludGVybmFsQXJyYXlJbmRleCA9IDAsXG4gICAgICAgIHN0cmlkZSA9IHRoaXMuZ3JpZC5zdHJpZGUsXG4gICAgICAgIGRpbWVuc2lvbjtcblxuICAgIHRoaXMucHJvY2Vzc0xpc3QucHVzaChwb2ludCk7XG4gICAgdGhpcy5zYW1wbGVQb2ludHMucHVzaChwb2ludCk7XG5cbiAgICBmb3IgKGRpbWVuc2lvbiA9IDA7IGRpbWVuc2lvbiA8IHRoaXMuZGltZW5zaW9uOyBkaW1lbnNpb24rKykge1xuICAgICAgICBpbnRlcm5hbEFycmF5SW5kZXggKz0gKChwb2ludFtkaW1lbnNpb25dIC8gdGhpcy5jZWxsU2l6ZSkgfCAwKSAqIHN0cmlkZVtkaW1lbnNpb25dO1xuICAgIH1cblxuICAgIHRoaXMuZ3JpZC5kYXRhW2ludGVybmFsQXJyYXlJbmRleF0gPSB0aGlzLnNhbXBsZVBvaW50cy5sZW5ndGg7IC8vIHN0b3JlIHRoZSBwb2ludCByZWZlcmVuY2VcblxuICAgIHJldHVybiBwb2ludDtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIHBvaW50IGlzIGluIHRoZSBuZWlnaGJvdXJob29kIG9mIGV4aXN0aW5nIHBvaW50c1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnQgUG9pbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBwb2ludCBpcyBpbiB0aGUgbmVpZ2hib3VyaG9vZCBvZiBhbm90aGVyIHBvaW50XG4gKiBAcHJvdGVjdGVkXG4gKi9cblBvaXNzb25EaXNrU2FtcGxpbmcucHJvdG90eXBlLmluTmVpZ2hib3VyaG9vZCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBkaW1lbnNpb25OdW1iZXIgPSB0aGlzLmRpbWVuc2lvbixcbiAgICAgICAgc3RyaWRlID0gdGhpcy5ncmlkLnN0cmlkZSxcbiAgICAgICAgbmVpZ2hib3VySW5kZXgsXG4gICAgICAgIGludGVybmFsQXJyYXlJbmRleCxcbiAgICAgICAgZGltZW5zaW9uLFxuICAgICAgICBjdXJyZW50RGltZW5zaW9uVmFsdWUsXG4gICAgICAgIGV4aXN0aW5nUG9pbnQ7XG5cbiAgICBmb3IgKG5laWdoYm91ckluZGV4ID0gMDsgbmVpZ2hib3VySW5kZXggPCB0aGlzLm5laWdoYm91cmhvb2QubGVuZ3RoOyBuZWlnaGJvdXJJbmRleCsrKSB7XG4gICAgICAgIGludGVybmFsQXJyYXlJbmRleCA9IDA7XG5cbiAgICAgICAgZm9yIChkaW1lbnNpb24gPSAwOyBkaW1lbnNpb24gPCBkaW1lbnNpb25OdW1iZXI7IGRpbWVuc2lvbisrKSB7XG4gICAgICAgICAgICBjdXJyZW50RGltZW5zaW9uVmFsdWUgPSAoKHBvaW50W2RpbWVuc2lvbl0gLyB0aGlzLmNlbGxTaXplKSB8IDApICsgdGhpcy5uZWlnaGJvdXJob29kW25laWdoYm91ckluZGV4XVtkaW1lbnNpb25dO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudERpbWVuc2lvblZhbHVlID49IDAgJiYgY3VycmVudERpbWVuc2lvblZhbHVlIDwgdGhpcy5ncmlkU2hhcGVbZGltZW5zaW9uXSkge1xuICAgICAgICAgICAgICAgIGludGVybmFsQXJyYXlJbmRleCArPSBjdXJyZW50RGltZW5zaW9uVmFsdWUgKiBzdHJpZGVbZGltZW5zaW9uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyaWQuZGF0YVtpbnRlcm5hbEFycmF5SW5kZXhdICE9PSAwKSB7XG4gICAgICAgICAgICBleGlzdGluZ1BvaW50ID0gdGhpcy5zYW1wbGVQb2ludHNbdGhpcy5ncmlkLmRhdGFbaW50ZXJuYWxBcnJheUluZGV4XSAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoc3F1YXJlZEV1Y2xpZGVhbkRpc3RhbmNlKHBvaW50LCBleGlzdGluZ1BvaW50KSA8IHRoaXMuc3F1YXJlZE1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFRyeSB0byBnZW5lcmF0ZSBhIG5ldyBwb2ludCBpbiB0aGUgZ3JpZCwgcmV0dXJucyBudWxsIGlmIGl0IHdhc24ndCBwb3NzaWJsZVxuICogQHJldHVybnMge0FycmF5fG51bGx9IFRoZSBhZGRlZCBwb2ludCBvciBudWxsXG4gKi9cblBvaXNzb25EaXNrU2FtcGxpbmcucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyaWVzLFxuICAgICAgICBhbmdsZSxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGN1cnJlbnRQb2ludCxcbiAgICAgICAgbmV3UG9pbnQsXG4gICAgICAgIGluU2hhcGUsXG4gICAgICAgIGk7XG5cbiAgICB3aGlsZSAodGhpcy5wcm9jZXNzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnQgPSB0aGlzLnByb2Nlc3NMaXN0LnNoaWZ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UG9pbnQgPSB0aGlzLmN1cnJlbnRQb2ludDtcblxuICAgICAgICBmb3IgKHRyaWVzID0gMDsgdHJpZXMgPCB0aGlzLm1heFRyaWVzOyB0cmllcysrKSB7XG4gICAgICAgICAgICBpblNoYXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZSArIHRoaXMuZGVsdGFEaXN0YW5jZSAqIHRoaXMucm5nKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gdGhpcy5ybmcoKSAqIE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc2luKGFuZ2xlKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gc3BoZXJlUmFuZG9tKHRoaXMuZGltZW5zaW9uLCB0aGlzLnJuZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGluU2hhcGUgJiYgaSA8IHRoaXMuZGltZW5zaW9uOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXdQb2ludFtpXSA9IGN1cnJlbnRQb2ludFtpXSArIG5ld1BvaW50W2ldICogZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgaW5TaGFwZSA9IChuZXdQb2ludFtpXSA+PSAwICYmIG5ld1BvaW50W2ldIDw9IHRoaXMuc2hhcGVbaV0gLSAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5TaGFwZSAmJiAhdGhpcy5pbk5laWdoYm91cmhvb2QobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0QWRkUG9pbnQobmV3UG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyaWVzID09PSB0aGlzLm1heFRyaWVzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQb2ludCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBmaWxsIHRoZSBncmlkLCBhZGRpbmcgYSByYW5kb20gcG9pbnQgdG8gc3RhcnQgdGhlIHByb2Nlc3MgaWYgbmVlZGVkLlxuICogV2lsbCBibG9jayB0aGUgdGhyZWFkLCBwcm9iYWJseSBiZXN0IHRvIHVzZSBpdCBpbiBhIHdlYiB3b3JrZXIgb3IgY2hpbGQgcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtBcnJheVtdfSBTYW1wbGUgcG9pbnRzXG4gKi9cblBvaXNzb25EaXNrU2FtcGxpbmcucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2FtcGxlUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmFkZFJhbmRvbVBvaW50KCk7XG4gICAgfVxuXG4gICAgd2hpbGUodGhpcy5uZXh0KCkpIHt9XG5cbiAgICByZXR1cm4gdGhpcy5zYW1wbGVQb2ludHM7XG59O1xuXG4vKipcbiAqIEdldCBhbGwgdGhlIHBvaW50cyBpbiB0aGUgZ3JpZC5cbiAqIEByZXR1cm5zIHtBcnJheVtdfSBTYW1wbGUgcG9pbnRzXG4gKi9cblBvaXNzb25EaXNrU2FtcGxpbmcucHJvdG90eXBlLmdldEFsbFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVQb2ludHM7XG59O1xuXG4vKipcbiAqIFJlaW5pdGlhbGl6ZSB0aGUgZ3JpZCBhcyB3ZWxsIGFzIHRoZSBpbnRlcm5hbCBzdGF0ZVxuICovXG5Qb2lzc29uRGlza1NhbXBsaW5nLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ3JpZERhdGEgPSB0aGlzLmdyaWQuZGF0YSxcbiAgICAgICAgaSA9IDA7XG5cbiAgICAvLyByZXNldCB0aGUgY2FjaGUgZ3JpZFxuICAgIGZvciAoaSA9IDA7IGkgPCBncmlkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBncmlkRGF0YVtpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gbmV3IGFycmF5IGZvciB0aGUgc2FtcGxlUG9pbnRzIGFzIGl0IGlzIHBhc3NlZCBieSByZWZlcmVuY2UgdG8gdGhlIG91dHNpZGVcbiAgICB0aGlzLnNhbXBsZVBvaW50cyA9IFtdO1xuXG4gICAgLy8gcmVzZXQgdGhlIGludGVybmFsIHN0YXRlXG4gICAgdGhpcy5jdXJyZW50UG9pbnQgPSBudWxsO1xuICAgIHRoaXMucHJvY2Vzc0xpc3QubGVuZ3RoID0gMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pc3NvbkRpc2tTYW1wbGluZztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/poisson-disk-sampling/src/poisson-disk-sampling.js\n");

/***/ }),

/***/ "./node_modules/poisson-disk-sampling/src/sphere-random.js":
/*!*****************************************************************!*\
  !*** ./node_modules/poisson-disk-sampling/src/sphere-random.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// sphere-random module by Mikola Lysenko under the MIT License\n// waiting for https://github.com/scijs/sphere-random/pull/1 to be merged\n\nmodule.exports = sampleSphere;\n\n/**\n * @param {int} d Dimensions\n * @param {Function} rng\n * @returns {Array}\n */\nfunction sampleSphere(d, rng) {\n    var v = new Array(d),\n        d2 = Math.floor(d/2) << 1,\n        r2 = 0.0,\n        rr,\n        r,\n        theta,\n        h,\n        i;\n\n    for (i = 0; i < d2; i += 2) {\n        rr = -2.0 * Math.log(rng());\n        r =  Math.sqrt(rr);\n        theta = 2.0 * Math.PI * rng();\n\n        r2+= rr;\n        v[i] = r * Math.cos(theta);\n        v[i+1] = r * Math.sin(theta);\n    }\n\n    if (d % 2) {\n        var x = Math.sqrt(-2.0 * Math.log(rng())) * Math.cos(2.0 * Math.PI * rng());\n        v[d - 1] = x;\n        r2+= Math.pow(x, 2);\n    }\n\n    h = 1.0 / Math.sqrt(r2);\n\n    for (i = 0; i < d; ++i) {\n        v[i] *= h;\n    }\n\n    return v;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9pc3Nvbi1kaXNrLXNhbXBsaW5nL3NyYy9zcGhlcmUtcmFuZG9tLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BvaXNzb24tZGlzay1zYW1wbGluZy9zcmMvc3BoZXJlLXJhbmRvbS5qcz9iMGI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBzcGhlcmUtcmFuZG9tIG1vZHVsZSBieSBNaWtvbGEgTHlzZW5rbyB1bmRlciB0aGUgTUlUIExpY2Vuc2Vcbi8vIHdhaXRpbmcgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2lqcy9zcGhlcmUtcmFuZG9tL3B1bGwvMSB0byBiZSBtZXJnZWRcblxubW9kdWxlLmV4cG9ydHMgPSBzYW1wbGVTcGhlcmU7XG5cbi8qKlxuICogQHBhcmFtIHtpbnR9IGQgRGltZW5zaW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gcm5nXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHNhbXBsZVNwaGVyZShkLCBybmcpIHtcbiAgICB2YXIgdiA9IG5ldyBBcnJheShkKSxcbiAgICAgICAgZDIgPSBNYXRoLmZsb29yKGQvMikgPDwgMSxcbiAgICAgICAgcjIgPSAwLjAsXG4gICAgICAgIHJyLFxuICAgICAgICByLFxuICAgICAgICB0aGV0YSxcbiAgICAgICAgaCxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBkMjsgaSArPSAyKSB7XG4gICAgICAgIHJyID0gLTIuMCAqIE1hdGgubG9nKHJuZygpKTtcbiAgICAgICAgciA9ICBNYXRoLnNxcnQocnIpO1xuICAgICAgICB0aGV0YSA9IDIuMCAqIE1hdGguUEkgKiBybmcoKTtcblxuICAgICAgICByMis9IHJyO1xuICAgICAgICB2W2ldID0gciAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgdltpKzFdID0gciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICB9XG5cbiAgICBpZiAoZCAlIDIpIHtcbiAgICAgICAgdmFyIHggPSBNYXRoLnNxcnQoLTIuMCAqIE1hdGgubG9nKHJuZygpKSkgKiBNYXRoLmNvcygyLjAgKiBNYXRoLlBJICogcm5nKCkpO1xuICAgICAgICB2W2QgLSAxXSA9IHg7XG4gICAgICAgIHIyKz0gTWF0aC5wb3coeCwgMik7XG4gICAgfVxuXG4gICAgaCA9IDEuMCAvIE1hdGguc3FydChyMik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZDsgKytpKSB7XG4gICAgICAgIHZbaV0gKj0gaDtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/poisson-disk-sampling/src/sphere-random.js\n");

/***/ }),

/***/ "./node_modules/zeros/zeros.js":
/*!*************************************!*\
  !*** ./node_modules/zeros/zeros.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ndarray = __webpack_require__(/*! ndarray */ \"./node_modules/ndarray/ndarray.js\")\n\nfunction dtypeToType(dtype) {\n  switch(dtype) {\n    case 'uint8':\n      return Uint8Array;\n    case 'uint16':\n      return Uint16Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'int8':\n      return Int8Array;\n    case 'int16':\n      return Int16Array;\n    case 'int32':\n      return Int32Array;\n    case 'float':\n    case 'float32':\n      return Float32Array;\n    case 'double':\n    case 'float64':\n      return Float64Array;\n    case 'uint8_clamped':\n      return Uint8ClampedArray;\n    case 'generic':\n    case 'buffer':\n    case 'data':\n    case 'dataview':\n      return ArrayBuffer;\n    case 'array':\n      return Array;\n  }\n}\n\nmodule.exports = function zeros(shape, dtype) {\n  dtype = dtype || 'float64';\n  var sz = 1;\n  for(var i=0; i<shape.length; ++i) {\n    sz *= shape[i];\n  }\n  return ndarray(new (dtypeToType(dtype))(sz), shape);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvemVyb3MvemVyb3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvemVyb3MvemVyb3MuanM/MmE2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCJuZGFycmF5XCIpXG5cbmZ1bmN0aW9uIGR0eXBlVG9UeXBlKGR0eXBlKSB7XG4gIHN3aXRjaChkdHlwZSkge1xuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gICAgY2FzZSAndWludDMyJzpcbiAgICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgICBjYXNlICdpbnQ4JzpcbiAgICAgIHJldHVybiBJbnQ4QXJyYXk7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgICAgcmV0dXJuIEludDE2QXJyYXk7XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgcmV0dXJuIEludDMyQXJyYXk7XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgICBjYXNlICdkb3VibGUnOlxuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcbiAgICBjYXNlICd1aW50OF9jbGFtcGVkJzpcbiAgICAgIHJldHVybiBVaW50OENsYW1wZWRBcnJheTtcbiAgICBjYXNlICdnZW5lcmljJzpcbiAgICBjYXNlICdidWZmZXInOlxuICAgIGNhc2UgJ2RhdGEnOlxuICAgIGNhc2UgJ2RhdGF2aWV3JzpcbiAgICAgIHJldHVybiBBcnJheUJ1ZmZlcjtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICByZXR1cm4gQXJyYXk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB6ZXJvcyhzaGFwZSwgZHR5cGUpIHtcbiAgZHR5cGUgPSBkdHlwZSB8fCAnZmxvYXQ2NCc7XG4gIHZhciBzeiA9IDE7XG4gIGZvcih2YXIgaT0wOyBpPHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgc3ogKj0gc2hhcGVbaV07XG4gIH1cbiAgcmV0dXJuIG5kYXJyYXkobmV3IChkdHlwZVRvVHlwZShkdHlwZSkpKHN6KSwgc2hhcGUpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zeros/zeros.js\n");

/***/ })

/******/ });